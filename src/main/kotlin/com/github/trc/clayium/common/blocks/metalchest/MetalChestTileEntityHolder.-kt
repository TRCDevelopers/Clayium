package com.github.trc.clayium.common.blocks.metalchest

import com.github.trc.clayium.api.ClayiumApi
import com.github.trc.clayium.api.capability.ClayiumDataCodecs.INITIALIZE_MCTE
import com.github.trc.clayium.api.metatileentity.SyncedTileEntityBase
import net.minecraft.block.state.IBlockState
import net.minecraft.nbt.NBTTagCompound
import net.minecraft.network.PacketBuffer
import net.minecraft.util.EnumFacing
import net.minecraft.util.math.BlockPos
import net.minecraft.world.World
import net.minecraftforge.common.capabilities.Capability
import net.minecraftforge.fml.relauncher.Side
import net.minecraftforge.fml.relauncher.SideOnly

/**
 * Source code from MetaTileEntityHolder
 */
class MetalChestTileEntityHolder : SyncedTileEntityBase() {
    var tileEntity: TileEntityMetalChest? = null
        set(sampleTileEntity) {
            sampleTileEntity?.holder = this
            field = sampleTileEntity
        }
    fun setMetaTileEntityFromSample(sampleMetaTileEntity: TileEntityMetalChest): TileEntityMetalChest {
        val newMetaTileEntity = sampleMetaTileEntity.createTileEntity()
        this.tileEntity = newMetaTileEntity
        if (world != null && !world.isRemote) {
            writeCustomData(INITIALIZE_MCTE) {
                newMetaTileEntity.writeInitialSyncData(this)
            }
            world.neighborChanged(pos, blockType, pos)
            markDirty()
        }
        return newMetaTileEntity
    }
    override fun writeToNBT(compound: NBTTagCompound): NBTTagCompound {
        super.writeToNBT(compound)
        return compound
    }

    override fun readFromNBT(compound: NBTTagCompound) {
        super.readFromNBT(compound)
    }
    

    override fun receiveCustomData(discriminator: Int, buf: PacketBuffer) {
        if (discriminator == INITIALIZE_MCTE) {
            receiveMteInitializationData(buf)
        } else {
            tileEntity?.receiveCustomData(discriminator, buf)
        }
    }

    private fun receiveMteInitializationData(buf: PacketBuffer) {
        val registry = ClayiumApi.mteManager.getRegistry(buf.readVarInt())
        val sampleMetaTileEntity = registry.getObjectById(buf.readVarInt()) ?: return
        val newMetaTileEntity = this.setMetaTileEntityFromSample(sampleMetaTileEntity)
        newMetaTileEntity.receiveInitialSyncData(buf)
        scheduleRenderUpdate()
    }

    override fun hasCapability(capability: Capability<*>, facing: EnumFacing?): Boolean {
        return tileEntity?.getCapability(capability, facing) != null || super.hasCapability(capability, facing)
    }

    override fun <T> getCapability(capability: Capability<T?>, facing: EnumFacing?): T? {
        return tileEntity?.getCapability(capability, facing) ?: super.getCapability(capability, facing)
    }

    fun scheduleRenderUpdate() {
        world?.markBlockRangeForRenderUpdate(pos, pos)
    }

    fun notifyNeighbors() {
        world?.notifyNeighborsOfStateChange(pos, blockType, true)
    }

    override fun shouldRefresh(world: World, pos: BlockPos, oldState: IBlockState, newSate: IBlockState): Boolean {
        return oldState.block != newSate.block
    }

    @SideOnly(Side.CLIENT)
    override fun shouldRenderInPass(pass: Int) = tileEntity?.shouldRenderInPass(pass) ?: super.shouldRenderInPass(pass)
    @Suppress("UsePropertyAccessSyntax") // `super.maxRenderDistanceSquared` errors with "Unresolved reference"
    @SideOnly(Side.CLIENT)
    override fun getMaxRenderDistanceSquared() = tileEntity?.getMaxRenderDistanceSquared() ?: super.getMaxRenderDistanceSquared()
    @SideOnly(Side.CLIENT)
    override fun getRenderBoundingBox() = tileEntity?.getRenderBoundingBox() ?: super.getRenderBoundingBox()
    override fun writeInitialSyncData(buf: PacketBuffer) {
        TODO("Not yet implemented")
    }

    override fun receiveInitialSyncData(buf: PacketBuffer) {
        
    }
}